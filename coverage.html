
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/taikicoco/shiraberu/internal/config/config.go (90.9%)</option>
				
				<option value="file1">github.com/taikicoco/shiraberu/internal/demo/demo.go (100.0%)</option>
				
				<option value="file2">github.com/taikicoco/shiraberu/internal/github/client.go (83.1%)</option>
				
				<option value="file3">github.com/taikicoco/shiraberu/internal/period/period.go (100.0%)</option>
				
				<option value="file4">github.com/taikicoco/shiraberu/internal/pr/fetcher.go (95.7%)</option>
				
				<option value="file5">github.com/taikicoco/shiraberu/internal/prompt/prompt.go (12.5%)</option>
				
				<option value="file6">github.com/taikicoco/shiraberu/internal/render/html.go (96.2%)</option>
				
				<option value="file7">github.com/taikicoco/shiraberu/internal/render/markdown.go (80.0%)</option>
				
				<option value="file8">github.com/taikicoco/shiraberu/internal/render/stats.go (94.4%)</option>
				
				<option value="file9">github.com/taikicoco/shiraberu/internal/server/server.go (51.4%)</option>
				
				<option value="file10">github.com/taikicoco/shiraberu/internal/spinner/spinner.go (100.0%)</option>
				
				<option value="file11">github.com/taikicoco/shiraberu/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "os"
        "path/filepath"

        "github.com/joho/godotenv"
)

type Config struct {
        Org       string
        Format    string
        OutputDir string
}

func Load() (*Config, error) <span class="cov8" title="1">{
        // .env ファイルを読み込み（存在しなくてもエラーにしない）
        _ = godotenv.Load()

        cfg := &amp;Config{
                Org:       os.Getenv("SHIRABERU_ORG"),
                Format:    getEnvOrDefault("SHIRABERU_FORMAT", "markdown"),
                OutputDir: getEnvOrDefault("SHIRABERU_OUTPUT_DIR", "./output"),
        }

        if cfg.OutputDir != "" </span><span class="cov8" title="1">{
                if len(cfg.OutputDir) &gt;= 2 &amp;&amp; cfg.OutputDir[:2] == "~/" </span><span class="cov8" title="1">{
                        cfg.OutputDir = filepath.Join(os.Getenv("HOME"), cfg.OutputDir[2:])
                }</span>
                <span class="cov8" title="1">if err := os.MkdirAll(cfg.OutputDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return cfg, nil</span>
}

func getEnvOrDefault(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package demo

import (
        "fmt"
        "math/rand"
        "sort"
        "time"

        "github.com/taikicoco/shiraberu/internal/github"
        "github.com/taikicoco/shiraberu/internal/pr"
        "github.com/taikicoco/shiraberu/internal/timezone"
)

var repos = []string{
        "api-server",
        "web-frontend",
        "mobile-app",
        "infra-terraform",
        "shared-libs",
}

var prTitles = []string{
        "feat: Add user authentication",
        "fix: Resolve memory leak in cache",
        "refactor: Extract common utilities",
        "docs: Update API documentation",
        "chore: Bump dependencies",
        "feat: Implement dark mode",
        "fix: Handle edge case in parser",
        "feat: Add export to CSV feature",
        "refactor: Migrate to new database",
        "fix: Correct timezone handling",
        "feat: Add notification system",
        "chore: Update CI/CD pipeline",
        "feat: Implement search functionality",
        "fix: Fix pagination bug",
        "refactor: Improve error handling",
}

// Demo generation constants
const (
        weekendActivityRate = 0.3 // Probability of activity on weekends
        draftPRRate         = 0.3 // Probability of generating a draft PR (1 - 0.7)
        maxOpenedPRs        = 4   // Max opened PRs per day (0-3)
        maxMergedPRs        = 5   // Max merged PRs per day (0-4)
        maxReviewedPRs      = 4   // Max reviewed PRs per day (0-3)
        maxAdditions        = 500 // Max line additions
        minAdditions        = 10  // Min line additions
        maxDeletions        = 200 // Max line deletions
        minDeletions        = 5   // Min line deletions
        maxChangedFiles     = 20  // Max changed files
        maxComments         = 10  // Max comments
)

// GenerateReport generates demo data for the given date range
func GenerateReport(startDate, endDate time.Time) (*pr.Report, *pr.Report) <span class="cov8" title="1">{
        r := rand.New(rand.NewSource(time.Now().UnixNano()))

        // Generate current period
        report := generatePeriodReport(startDate, endDate, r, "demo-org")

        // Generate previous period for comparison (previous month)
        prevEndDate := startDate.AddDate(0, 0, -1)
        prevStartDate := time.Date(prevEndDate.Year(), prevEndDate.Month(), 1, 0, 0, 0, 0, prevEndDate.Location())
        previousReport := generatePeriodReport(prevStartDate, prevEndDate, r, "demo-org")

        return report, previousReport
}</span>

func generatePeriodReport(startDate, endDate time.Time, r *rand.Rand, org string) *pr.Report <span class="cov8" title="1">{
        days := []pr.DailyPRs{}

        for d := startDate; !d.After(endDate); d = d.AddDate(0, 0, 1) </span><span class="cov8" title="1">{
                date := time.Date(d.Year(), d.Month(), d.Day(), 0, 0, 0, 0, timezone.JST)

                // Skip some days randomly (weekends have less activity)
                weekday := date.Weekday()
                if weekday == time.Saturday || weekday == time.Sunday </span><span class="cov8" title="1">{
                        if r.Float32() &gt; weekendActivityRate </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">day := pr.DailyPRs{Date: date}

                // Generate opened PRs
                openedCount := r.Intn(maxOpenedPRs)
                for i := 0; i &lt; openedCount; i++ </span><span class="cov8" title="1">{
                        day.Opened = append(day.Opened, generatePR(r, date, "open"))
                }</span>

                // Generate draft PRs
                <span class="cov8" title="1">if r.Float32() &lt; draftPRRate </span><span class="cov8" title="1">{
                        day.Draft = append(day.Draft, generatePR(r, date, "draft"))
                }</span>

                // Generate merged PRs
                <span class="cov8" title="1">mergedCount := r.Intn(maxMergedPRs)
                for i := 0; i &lt; mergedCount; i++ </span><span class="cov8" title="1">{
                        p := generatePR(r, date, "merged")
                        mergedAt := date.Add(time.Duration(r.Intn(24)) * time.Hour)
                        p.MergedAt = &amp;mergedAt
                        day.Merged = append(day.Merged, p)
                }</span>

                // Generate reviewed PRs
                <span class="cov8" title="1">reviewedCount := r.Intn(maxReviewedPRs)
                for i := 0; i &lt; reviewedCount; i++ </span><span class="cov8" title="1">{
                        day.Reviewed = append(day.Reviewed, generatePR(r, date, "open"))
                }</span>

                // Only add day if it has any PRs
                <span class="cov8" title="1">if len(day.Opened) &gt; 0 || len(day.Draft) &gt; 0 || len(day.Merged) &gt; 0 || len(day.Reviewed) &gt; 0 </span><span class="cov8" title="1">{
                        days = append(days, day)
                }</span>
        }

        // Sort by date descending (newest first) to match fetcher.go behavior
        <span class="cov8" title="1">sort.Slice(days, func(i, j int) bool </span><span class="cov8" title="1">{
                return days[i].Date.After(days[j].Date)
        }</span>)

        <span class="cov8" title="1">return &amp;pr.Report{
                GeneratedAt: time.Now(),
                StartDate:   startDate,
                EndDate:     endDate,
                Org:         org,
                Days:        days,
        }</span>
}

func generatePR(r *rand.Rand, date time.Time, state string) github.PullRequest <span class="cov8" title="1">{
        repo := repos[r.Intn(len(repos))]
        title := prTitles[r.Intn(len(prTitles))]

        additions := r.Intn(maxAdditions) + minAdditions
        deletions := r.Intn(maxDeletions) + minDeletions

        return github.PullRequest{
                Title:        title,
                URL:          "https://github.com/demo-org/" + repo + "/pull/" + randomPRNumber(r),
                Repository:   repo,
                State:        state,
                IsDraft:      state == "draft",
                CreatedAt:    date,
                UpdatedAt:    date.Add(time.Duration(r.Intn(48)) * time.Hour),
                Additions:    additions,
                Deletions:    deletions,
                ChangedFiles: r.Intn(maxChangedFiles) + 1,
                Comments:     r.Intn(maxComments),
        }
}</span>

func randomPRNumber(r *rand.Rand) string <span class="cov8" title="1">{
        n := r.Intn(9000) + 1000
        return fmt.Sprintf("%d", n)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package github

import (
        "encoding/json"
        "fmt"
        "os/exec"
        "strings"
        "time"

        apperrors "github.com/taikicoco/shiraberu/internal/errors"
)

// CommandExecutor はコマンド実行を抽象化するインターフェース
type CommandExecutor interface {
        Execute(name string, args ...string) ([]byte, error)
}

// DefaultExecutor は実際のコマンドを実行するデフォルト実装
type DefaultExecutor struct{}

// Execute はシェルコマンドを実行し、標準出力を返す
func (e *DefaultExecutor) Execute(name string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.Command(name, args...)
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("command failed: %w\n%s", err, string(exitErr.Stderr))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

type Client struct {
        username string
        executor CommandExecutor
}

// ClientOption はClientの設定オプション
type ClientOption func(*Client)

// WithExecutor はCommandExecutorを設定するオプション
func WithExecutor(e CommandExecutor) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.executor = e
        }</span>
}

func NewClient(opts ...ClientOption) (*Client, error) <span class="cov8" title="1">{
        c := &amp;Client{
                executor: &amp;DefaultExecutor{},
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(c)
        }</span>

        <span class="cov8" title="1">username, err := c.getUsername()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get GitHub username: %w", err)
        }</span>
        <span class="cov8" title="1">c.username = username
        return c, nil</span>
}

func (c *Client) Username() string <span class="cov8" title="1">{
        return c.username
}</span>

func (c *Client) getUsername() (string, error) <span class="cov8" title="1">{
        out, err := c.executor.Execute("gh", "api", "user", "--jq", ".login")
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">username := strings.TrimSpace(string(out))
        if username == "" </span><span class="cov8" title="1">{
                return "", apperrors.ErrEmptyUsername
        }</span>
        <span class="cov8" title="1">return username, nil</span>
}

// searchQuery is the GraphQL query for searching PRs.
// Uses 100 results per page for pagination.
const searchQuery = `
query($q: String!, $cursor: String) {
  search(query: $q, type: ISSUE, first: 100, after: $cursor) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      ... on PullRequest {
        title
        url
        state
        isDraft
        createdAt
        mergedAt
        updatedAt
        additions
        deletions
        changedFiles
        comments {
          totalCount
        }
        repository {
          name
        }
      }
    }
  }
}
`

type graphQLResponse struct {
        Data struct {
                Search struct {
                        PageInfo struct {
                                HasNextPage bool   `json:"hasNextPage"`
                                EndCursor   string `json:"endCursor"`
                        } `json:"pageInfo"`
                        Nodes []struct {
                                Title        string `json:"title"`
                                URL          string `json:"url"`
                                State        string `json:"state"`
                                IsDraft      bool   `json:"isDraft"`
                                CreatedAt    string `json:"createdAt"`
                                MergedAt     string `json:"mergedAt"`
                                UpdatedAt    string `json:"updatedAt"`
                                Additions    int    `json:"additions"`
                                Deletions    int    `json:"deletions"`
                                ChangedFiles int    `json:"changedFiles"`
                                Comments     struct {
                                        TotalCount int `json:"totalCount"`
                                } `json:"comments"`
                                Repository struct {
                                        Name string `json:"name"`
                                } `json:"repository"`
                        } `json:"nodes"`
                } `json:"search"`
        } `json:"data"`
}

func (c *Client) SearchPRs(org string, query string, dateFilter string) ([]PullRequest, error) <span class="cov8" title="1">{
        q := fmt.Sprintf("%s org:%s %s", query, org, dateFilter)

        var allPRs []PullRequest
        var cursor string

        for </span><span class="cov8" title="1">{
                args := []string{"api", "graphql",
                        "-f", "q=" + q,
                        "-f", "query=" + searchQuery,
                }
                if cursor != "" </span><span class="cov8" title="1">{
                        args = append(args, "-f", "cursor="+cursor)
                }</span>

                <span class="cov8" title="1">out, err := c.executor.Execute("gh", args...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("gh api graphql failed: %w", err)
                }</span>

                <span class="cov8" title="1">var resp graphQLResponse
                if err := json.Unmarshal(out, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse response: %w", err)
                }</span>

                <span class="cov8" title="1">for _, node := range resp.Data.Search.Nodes </span><span class="cov8" title="1">{
                        if node.URL == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">pr := PullRequest{
                                Title:        node.Title,
                                URL:          node.URL,
                                Repository:   node.Repository.Name,
                                State:        normalizeState(node.State),
                                IsDraft:      node.IsDraft,
                                Additions:    node.Additions,
                                Deletions:    node.Deletions,
                                ChangedFiles: node.ChangedFiles,
                                Comments:     node.Comments.TotalCount,
                        }

                        if t, err := time.Parse(time.RFC3339, node.CreatedAt); err == nil </span><span class="cov8" title="1">{
                                pr.CreatedAt = t
                        }</span>
                        <span class="cov8" title="1">if t, err := time.Parse(time.RFC3339, node.UpdatedAt); err == nil </span><span class="cov8" title="1">{
                                pr.UpdatedAt = t
                        }</span>
                        <span class="cov8" title="1">if node.MergedAt != "" </span><span class="cov8" title="1">{
                                if t, err := time.Parse(time.RFC3339, node.MergedAt); err == nil </span><span class="cov8" title="1">{
                                        pr.MergedAt = &amp;t
                                }</span>
                        }

                        <span class="cov8" title="1">allPRs = append(allPRs, pr)</span>
                }

                <span class="cov8" title="1">if !resp.Data.Search.PageInfo.HasNextPage </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">cursor = resp.Data.Search.PageInfo.EndCursor</span>
        }

        <span class="cov8" title="1">return allPRs, nil</span>
}

func normalizeState(state string) string <span class="cov8" title="1">{
        switch state </span>{
        case "MERGED":<span class="cov8" title="1">
                return "merged"</span>
        case "OPEN":<span class="cov8" title="1">
                return "open"</span>
        case "CLOSED":<span class="cov8" title="1">
                return "closed"</span>
        default:<span class="cov8" title="1">
                return state</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package period

import "time"

// Type は期間の種類を表す
type Type string

const (
        TypeWeek   Type = "week"
        TypeMonth  Type = "month"
        TypeCustom Type = "custom"
)

// CalcPrevious は指定された期間の直前の同等期間を計算する
func CalcPrevious(startDate, endDate time.Time, periodType Type) (time.Time, time.Time) <span class="cov8" title="1">{
        switch periodType </span>{
        case TypeWeek:<span class="cov8" title="1">
                // Previous week (Monday to Sunday)
                prevEndDate := startDate.AddDate(0, 0, -1)
                prevStartDate := prevEndDate.AddDate(0, 0, -6)
                return prevStartDate, prevEndDate</span>

        case TypeMonth:<span class="cov8" title="1">
                // Previous month (1st to last day)
                prevEndDate := startDate.AddDate(0, 0, -1)
                prevStartDate := time.Date(prevEndDate.Year(), prevEndDate.Month(), 1, 0, 0, 0, 0, prevEndDate.Location())
                return prevStartDate, prevEndDate</span>

        default:<span class="cov8" title="1"> // TypeCustom
                // Same duration before
                duration := endDate.Sub(startDate) + 24*time.Hour
                prevEndDate := startDate.AddDate(0, 0, -1)
                prevStartDate := prevEndDate.Add(-duration + 24*time.Hour)
                return prevStartDate, prevEndDate</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package pr

import (
        "sort"
        "time"

        "github.com/taikicoco/shiraberu/internal/github"
        "github.com/taikicoco/shiraberu/internal/timezone"
)

// PRSearcher はPR検索機能を抽象化するインターフェース
type PRSearcher interface {
        Username() string
        SearchPRs(org string, query string, dateFilter string) ([]github.PullRequest, error)
}

type DailyPRs struct {
        Date     time.Time
        Opened   []github.PullRequest
        Draft    []github.PullRequest
        Merged   []github.PullRequest
        Reviewed []github.PullRequest
}

type Report struct {
        GeneratedAt time.Time
        StartDate   time.Time
        EndDate     time.Time
        Org         string
        Days        []DailyPRs
}

type Fetcher struct {
        client PRSearcher
}

func NewFetcher(client PRSearcher) *Fetcher <span class="cov8" title="1">{
        return &amp;Fetcher{client: client}
}</span>

func (f *Fetcher) Fetch(org string, startDate, endDate time.Time) (*Report, error) <span class="cov8" title="1">{
        username := f.client.Username()

        // JST timezone for date range
        startTime := time.Date(startDate.Year(), startDate.Month(), startDate.Day(), 0, 0, 0, 0, timezone.JST)
        endTime := time.Date(endDate.Year(), endDate.Month(), endDate.Day(), 23, 59, 59, 0, timezone.JST)

        dateRange := startTime.Format(time.RFC3339) + ".." + endTime.Format(time.RFC3339)

        // Opened PRs
        openedPRs, err := f.client.SearchPRs(org, "is:pr author:"+username+" is:open", "created:"+dateRange)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Merged PRs
        <span class="cov8" title="1">mergedPRs, err := f.client.SearchPRs(org, "is:pr author:"+username+" is:merged", "merged:"+dateRange)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Reviewed PRs
        <span class="cov8" title="1">reviewedPRs, err := f.client.SearchPRs(org, "is:pr reviewed-by:"+username+" -author:"+username, "updated:"+dateRange)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">days := groupByDate(openedPRs, mergedPRs, reviewedPRs)

        return &amp;Report{
                GeneratedAt: time.Now(),
                StartDate:   startDate,
                EndDate:     endDate,
                Org:         org,
                Days:        days,
        }, nil</span>
}

func groupByDate(opened, merged, reviewed []github.PullRequest) []DailyPRs <span class="cov8" title="1">{
        dateMap := make(map[string]*DailyPRs)

        addPR := func(pr github.PullRequest, category string) </span><span class="cov8" title="1">{
                date := pr.CreatedAt
                if category == "merged" &amp;&amp; pr.MergedAt != nil </span><span class="cov8" title="1">{
                        date = *pr.MergedAt
                }</span>
                <span class="cov8" title="1">if category == "reviewed" </span><span class="cov8" title="1">{
                        date = pr.UpdatedAt
                }</span>

                // UTCからJSTに変換してからグループ化
                <span class="cov8" title="1">dateJST := date.In(timezone.JST)
                dateStr := dateJST.Format("2006-01-02")
                if _, ok := dateMap[dateStr]; !ok </span><span class="cov8" title="1">{
                        dateMap[dateStr] = &amp;DailyPRs{
                                Date: time.Date(dateJST.Year(), dateJST.Month(), dateJST.Day(), 0, 0, 0, 0, timezone.JST),
                        }
                }</span>

                <span class="cov8" title="1">switch category </span>{
                case "opened":<span class="cov8" title="1">
                        dateMap[dateStr].Opened = append(dateMap[dateStr].Opened, pr)</span>
                case "draft":<span class="cov8" title="1">
                        dateMap[dateStr].Draft = append(dateMap[dateStr].Draft, pr)</span>
                case "merged":<span class="cov8" title="1">
                        dateMap[dateStr].Merged = append(dateMap[dateStr].Merged, pr)</span>
                case "reviewed":<span class="cov8" title="1">
                        dateMap[dateStr].Reviewed = append(dateMap[dateStr].Reviewed, pr)</span>
                }
        }

        <span class="cov8" title="1">for _, pr := range opened </span><span class="cov8" title="1">{
                if pr.IsDraft </span><span class="cov8" title="1">{
                        addPR(pr, "draft")
                }</span> else<span class="cov8" title="1"> {
                        addPR(pr, "opened")
                }</span>
        }
        <span class="cov8" title="1">for _, pr := range merged </span><span class="cov8" title="1">{
                addPR(pr, "merged")
        }</span>
        <span class="cov8" title="1">for _, pr := range reviewed </span><span class="cov8" title="1">{
                addPR(pr, "reviewed")
        }</span>

        <span class="cov8" title="1">days := make([]DailyPRs, 0, len(dateMap))
        for _, d := range dateMap </span><span class="cov8" title="1">{
                days = append(days, *d)
        }</span>

        <span class="cov8" title="1">sort.Slice(days, func(i, j int) bool </span><span class="cov8" title="1">{
                return days[i].Date.After(days[j].Date)
        }</span>)

        <span class="cov8" title="1">return days</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package prompt

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/manifoldco/promptui"
        "github.com/taikicoco/shiraberu/internal/config"
        apperrors "github.com/taikicoco/shiraberu/internal/errors"
        "github.com/taikicoco/shiraberu/internal/period"
)

const (
        backOption   = "← Back"
        monthsToShow = 12
)

type Options struct {
        Org        string
        StartDate  time.Time
        EndDate    time.Time
        PeriodType period.Type
        Format     string
        OutputPath string
}

type step int

const (
        stepOrg step = iota
        stepPeriodMode
        stepPeriodDetail
        stepFormat
        stepDone
)

func Run(cfg *config.Config) (*Options, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        opts := &amp;Options{}

        currentStep := stepOrg

        for currentStep != stepDone </span><span class="cov0" title="0">{
                switch currentStep </span>{
                case stepOrg:<span class="cov0" title="0">
                        opts.Org = promptText(reader, "Organization", cfg.Org)
                        if opts.Org == "" </span><span class="cov0" title="0">{
                                return nil, apperrors.ErrOrgRequired
                        }</span>
                        <span class="cov0" title="0">currentStep = stepPeriodMode</span>

                case stepPeriodMode:<span class="cov0" title="0">
                        modes := []string{"Single day", "Date range", backOption}
                        idx := promptSelect("Period type", modes, 0)
                        if idx == 2 </span><span class="cov0" title="0">{ // Back
                                currentStep = stepOrg
                                continue</span>
                        }
                        <span class="cov0" title="0">var goBack bool
                        if idx == 0 </span><span class="cov0" title="0">{
                                opts.StartDate, opts.EndDate, goBack = promptSingleDay(reader)
                                opts.PeriodType = period.TypeCustom
                        }</span> else<span class="cov0" title="0"> {
                                opts.StartDate, opts.EndDate, opts.PeriodType, goBack = promptDateRange(reader)
                        }</span>
                        <span class="cov0" title="0">if goBack </span><span class="cov0" title="0">{
                                continue</span> // Stay at stepPeriodMode
                        }
                        <span class="cov0" title="0">currentStep = stepFormat</span>

                case stepFormat:<span class="cov0" title="0">
                        formats := []string{"Markdown", "HTML", "HTML (open in browser)", backOption}
                        formatValues := []string{"markdown", "html", "browser"}
                        defaultIdx := 0
                        for i, v := range formatValues </span><span class="cov0" title="0">{
                                if v == cfg.Format </span><span class="cov0" title="0">{
                                        defaultIdx = i
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">idx := promptSelect("Output format", formats, defaultIdx)
                        if idx == 3 </span><span class="cov0" title="0">{ // Back
                                currentStep = stepPeriodMode
                                continue</span>
                        }
                        <span class="cov0" title="0">opts.Format = formatValues[idx]
                        currentStep = stepDone</span>
                }
        }

        // Output path (auto-generate if output_dir is set)
        <span class="cov0" title="0">if opts.Format != "browser" &amp;&amp; cfg.OutputDir != "" </span><span class="cov0" title="0">{
                ext := ".md"
                if opts.Format == "html" </span><span class="cov0" title="0">{
                        ext = ".html"
                }</span>
                <span class="cov0" title="0">filename := generateFilename(opts.StartDate, opts.EndDate, ext)
                opts.OutputPath = filepath.Join(cfg.OutputDir, filename)</span>
        }

        <span class="cov0" title="0">return opts, nil</span>
}

func generateFilename(start, end time.Time, ext string) string <span class="cov8" title="1">{
        if start.Equal(end) </span><span class="cov8" title="1">{
                return start.Format("2006-01-02") + ext
        }</span>
        <span class="cov8" title="1">return start.Format("2006-01-02") + "_" + end.Format("2006-01-02") + ext</span>
}

func promptSingleDay(reader *bufio.Reader) (time.Time, time.Time, bool) <span class="cov0" title="0">{
        now := time.Now()
        today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
        yesterday := today.AddDate(0, 0, -1)

        options := []string{
                fmt.Sprintf("Today (%s)", today.Format("2006-01-02")),
                fmt.Sprintf("Yesterday (%s)", yesterday.Format("2006-01-02")),
                "Enter date",
                backOption,
        }
        idx := promptSelect("Select date", options, 0)

        if idx == 3 </span><span class="cov0" title="0">{ // Back
                return time.Time{}, time.Time{}, true
        }</span>

        <span class="cov0" title="0">var date time.Time
        switch idx </span>{
        case 0:<span class="cov0" title="0">
                date = today</span>
        case 1:<span class="cov0" title="0">
                date = yesterday</span>
        case 2:<span class="cov0" title="0">
                date = promptDate(reader, "Date (YYYY-MM-DD)", today)</span>
        }

        <span class="cov0" title="0">return date, date, false</span>
}

func promptDateRange(reader *bufio.Reader) (time.Time, time.Time, period.Type, bool) <span class="cov0" title="0">{
        now := time.Now()
        today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
        weekdays := []string{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

        // Calculate this Monday
        weekday := int(today.Weekday())
        if weekday == 0 </span><span class="cov0" title="0">{
                weekday = 7
        }</span>
        <span class="cov0" title="0">thisMonday := today.AddDate(0, 0, -(weekday - 1))
        lastMonday := thisMonday.AddDate(0, 0, -7)
        lastSunday := thisMonday.AddDate(0, 0, -1)

        // First day of this month
        thisMonthStart := time.Date(today.Year(), today.Month(), 1, 0, 0, 0, 0, today.Location())
        // Last month
        lastMonthStart := thisMonthStart.AddDate(0, -1, 0)
        lastMonthEnd := thisMonthStart.AddDate(0, 0, -1)

        options := []string{
                fmt.Sprintf("This week (%s %s - %s %s)", thisMonday.Format("1/2"), weekdays[thisMonday.Weekday()], today.Format("1/2"), weekdays[today.Weekday()]),
                fmt.Sprintf("Last week (%s %s - %s %s)", lastMonday.Format("1/2"), weekdays[lastMonday.Weekday()], lastSunday.Format("1/2"), weekdays[lastSunday.Weekday()]),
                fmt.Sprintf("This month (%s - %s)", thisMonthStart.Format("1/2"), today.Format("1/2")),
                fmt.Sprintf("Last month (%s - %s)", lastMonthStart.Format("1/2"), lastMonthEnd.Format("1/2")),
                "Select month",
                "Enter dates",
                backOption,
        }
        idx := promptSelect("Select range", options, 0)

        if idx == 6 </span><span class="cov0" title="0">{ // Back
                return time.Time{}, time.Time{}, "", true
        }</span>

        <span class="cov0" title="0">var start, end time.Time
        var periodType period.Type
        switch idx </span>{
        case 0:<span class="cov0" title="0"> // This week
                start, end = thisMonday, today
                periodType = period.TypeWeek</span>
        case 1:<span class="cov0" title="0"> // Last week
                start, end = lastMonday, lastSunday
                periodType = period.TypeWeek</span>
        case 2:<span class="cov0" title="0"> // This month
                start, end = thisMonthStart, today
                periodType = period.TypeMonth</span>
        case 3:<span class="cov0" title="0"> // Last month
                start, end = lastMonthStart, lastMonthEnd
                periodType = period.TypeMonth</span>
        case 4:<span class="cov0" title="0"> // Select month
                start, end = promptSelectMonth(today)
                periodType = period.TypeMonth</span>
        case 5:<span class="cov0" title="0"> // Enter dates
                start = promptDate(reader, "Start date (YYYY-MM-DD)", today.AddDate(0, 0, -7))
                end = promptDate(reader, "End date (YYYY-MM-DD)", today)
                periodType = period.TypeCustom</span>
        }

        // Confirm
        <span class="cov0" title="0">start, end = confirmDateRange(reader, start, end)
        return start, end, periodType, false</span>
}

func promptSelectMonth(today time.Time) (time.Time, time.Time) <span class="cov8" title="1">{
        // Generate past months
        options := make([]string, monthsToShow)
        months := make([]time.Time, monthsToShow)

        for i := 0; i &lt; monthsToShow; i++ </span><span class="cov8" title="1">{
                monthStart := time.Date(today.Year(), today.Month(), 1, 0, 0, 0, 0, today.Location()).AddDate(0, -i, 0)
                months[i] = monthStart
                options[i] = monthStart.Format("2006-01")
        }</span>

        <span class="cov8" title="1">idx := promptSelect("Select month", options, 0)

        start := months[idx]
        end := start.AddDate(0, 1, -1) // Last day of the month

        return start, end</span>
}

func confirmDateRange(reader *bufio.Reader, start, end time.Time) (time.Time, time.Time) <span class="cov0" title="0">{
        fmt.Printf("\nPeriod: %s - %s\n", start.Format("2006-01-02"), end.Format("2006-01-02"))
        fmt.Print("? Confirm? [Enter: OK / s: change start / e: change end]: ")

        input, err := reader.ReadString('\n')
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                // On error, return current values
                return start, end
        }</span>
        <span class="cov0" title="0">input = strings.TrimSpace(strings.ToLower(input))

        switch input </span>{
        case "s":<span class="cov0" title="0">
                start = promptDate(reader, "Start date (YYYY-MM-DD)", start)
                return confirmDateRange(reader, start, end)</span>
        case "e":<span class="cov0" title="0">
                end = promptDate(reader, "End date (YYYY-MM-DD)", end)
                return confirmDateRange(reader, start, end)</span>
        default:<span class="cov0" title="0">
                return start, end</span>
        }
}

func promptDate(reader *bufio.Reader, label string, defaultDate time.Time) time.Time <span class="cov0" title="0">{
        defaultStr := defaultDate.Format("2006-01-02")
        input := promptText(reader, label, defaultStr)

        parsed, err := time.Parse("2006-01-02", input)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("  Invalid date format. Using default.")
                return defaultDate
        }</span>
        <span class="cov0" title="0">return parsed</span>
}

func promptText(reader *bufio.Reader, label string, defaultVal string) string <span class="cov0" title="0">{
        if defaultVal != "" </span><span class="cov0" title="0">{
                fmt.Printf("? %s [%s]: ", label, defaultVal)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("? %s: ", label)
        }</span>

        <span class="cov0" title="0">input, err := reader.ReadString('\n')
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                // On error, return default value
                return defaultVal
        }</span>
        <span class="cov0" title="0">input = strings.TrimSpace(input)

        if input == "" </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return input</span>
}

func promptSelect(label string, options []string, defaultIdx int) int <span class="cov8" title="1">{
        prompt := promptui.Select{
                Label:     label,
                Items:     options,
                CursorPos: defaultIdx,
                Templates: &amp;promptui.SelectTemplates{
                        Label:    "? {{ . }}",
                        Active:   "\U0001F449 {{ . | cyan }}",
                        Inactive: "   {{ . }}",
                        Selected: "\U00002705 {{ . | green }}",
                },
        }

        idx, _, err := prompt.Run()
        if err != nil </span><span class="cov8" title="1">{
                return defaultIdx
        }</span>
        <span class="cov0" title="0">return idx</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package render

import (
        "embed"
        "encoding/json"
        "html/template"
        "io"

        "github.com/taikicoco/shiraberu/internal/github"
        "github.com/taikicoco/shiraberu/internal/pr"
)

//go:embed templates/*.html
var templateFS embed.FS

var htmlTemplate *template.Template

func init() <span class="cov8" title="1">{
        funcMap := template.FuncMap{
                "add": func(a, b int) int </span><span class="cov8" title="1">{ return a + b }</span>,
                "json": func(v interface{}) template.JS <span class="cov8" title="1">{
                        b, _ := json.Marshal(v)
                        return template.JS(b)
                }</span>,
        }
        <span class="cov8" title="1">var err error
        htmlTemplate, err = template.New("").Funcs(funcMap).ParseFS(templateFS, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func RenderHTML(w io.Writer, report *pr.Report, previousReport *pr.Report) error <span class="cov8" title="1">{
        summary := calcSummary(report)
        dailyStats := calcDailyStats(report)
        weeklyStats := calcWeeklyStats(report)
        monthlyStats := calcMonthlyStats(report)
        repoStats := calcRepoStats(report)
        summaryDiff := calcSummaryDiff(summary, previousReport)
        daysJSON := convertToDaysJSON(report)

        data := HTMLData{
                Report:            report,
                Summary:           summary,
                SummaryDiff:       summaryDiff,
                DailyStats:        dailyStats,
                WeeklyStats:       weeklyStats,
                MonthlyStats:      monthlyStats,
                RepoStats:         repoStats,
                Weekdays:          []string{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"},
                PeriodLabel:       formatPeriod(report.StartDate, report.EndDate),
                DaysJSON:          daysJSON,
                OriginalStartDate: report.StartDate.Format("2006-01-02"),
                OriginalEndDate:   report.EndDate.Format("2006-01-02"),
        }
        return htmlTemplate.ExecuteTemplate(w, "report.html", data)
}</span>

func convertToDaysJSON(report *pr.Report) []DayJSON <span class="cov8" title="1">{
        var days []DayJSON
        for _, day := range report.Days </span><span class="cov8" title="1">{
                d := DayJSON{
                        Date:     day.Date.Format("2006-01-02"),
                        Opened:   convertPRsToJSON(day.Opened),
                        Draft:    convertPRsToJSON(day.Draft),
                        Merged:   convertPRsToJSON(day.Merged),
                        Reviewed: convertPRsToJSON(day.Reviewed),
                }
                days = append(days, d)
        }</span>
        <span class="cov8" title="1">return days</span>
}

func convertPRsToJSON(prs []github.PullRequest) []PRJSON <span class="cov8" title="1">{
        result := make([]PRJSON, 0, len(prs))
        for _, p := range prs </span><span class="cov8" title="1">{
                result = append(result, PRJSON{
                        Title:      p.Title,
                        URL:        p.URL,
                        Repository: p.Repository,
                        State:      p.State,
                        IsDraft:    p.IsDraft,
                        Additions:  p.Additions,
                        Deletions:  p.Deletions,
                        Comments:   p.Comments,
                })
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package render

import (
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/taikicoco/shiraberu/internal/github"
        "github.com/taikicoco/shiraberu/internal/pr"
)

func formatPeriod(start, end time.Time) string <span class="cov8" title="1">{
        if start.Equal(end) </span><span class="cov8" title="1">{
                return start.Format("2006-01-02")
        }</span>
        <span class="cov8" title="1">return start.Format("2006-01-02") + " - " + end.Format("2006-01-02")</span>
}

func RenderMarkdown(w io.Writer, report *pr.Report) error <span class="cov8" title="1">{
        periodLabel := formatPeriod(report.StartDate, report.EndDate)

        fmt.Fprintf(w, "# PR Log (%s)\n\n", periodLabel)
        fmt.Fprintf(w, "Organization: %s\n", report.Org)
        fmt.Fprintf(w, "Generated: %s\n\n", report.GeneratedAt.Format("2006-01-02 15:04"))

        if len(report.Days) == 0 </span><span class="cov8" title="1">{
                fmt.Fprintln(w, "No pull requests found.")
                return nil
        }</span>

        <span class="cov8" title="1">weekdays := []string{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

        for _, day := range report.Days </span><span class="cov8" title="1">{
                weekday := weekdays[day.Date.Weekday()]
                fmt.Fprintf(w, "## %s (%s)\n\n", day.Date.Format("2006-01-02"), weekday)

                if len(day.Opened) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintln(w, "### Opened")
                        for _, p := range day.Opened </span><span class="cov8" title="1">{
                                writePRLine(w, p)
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintln(w)</span>
                }

                <span class="cov8" title="1">if len(day.Draft) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintln(w, "### Draft")
                        for _, p := range day.Draft </span><span class="cov0" title="0">{
                                writePRLine(w, p)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(w)</span>
                }

                <span class="cov8" title="1">if len(day.Merged) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintln(w, "### Merged")
                        for _, p := range day.Merged </span><span class="cov8" title="1">{
                                writePRLine(w, p)
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintln(w)</span>
                }

                <span class="cov8" title="1">if len(day.Reviewed) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintln(w, "### Reviewed")
                        for _, p := range day.Reviewed </span><span class="cov0" title="0">{
                                writePRLine(w, p)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(w)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func writePRLine(w io.Writer, p github.PullRequest) <span class="cov8" title="1">{
        state := capitalize(p.State)
        _, _ = fmt.Fprintf(w, "- [%s](%s) - %s (%s)\n", p.Title, p.URL, p.Repository, state)
}</span>

func capitalize(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(s[:1]) + s[1:]</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package render

import (
        "fmt"
        "sort"
        "time"

        "github.com/taikicoco/shiraberu/internal/pr"
)

func calcSummary(report *pr.Report) Summary <span class="cov8" title="1">{
        var s Summary
        for _, day := range report.Days </span><span class="cov8" title="1">{
                s.OpenedCount += len(day.Opened)
                s.DraftCount += len(day.Draft)
                s.MergedCount += len(day.Merged)
                s.ReviewedCount += len(day.Reviewed)
                // Additions/Deletions are only counted for merged PRs
                for _, p := range day.Merged </span><span class="cov8" title="1">{
                        s.Additions += p.Additions
                        s.Deletions += p.Deletions
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

func calcDailyStats(report *pr.Report) []DailyStat <span class="cov8" title="1">{
        // 期間内の全日を含むマップを作成
        dayMap := make(map[string]*DailyStat)

        // まず期間内の全日を0で初期化
        for d := report.StartDate; !d.After(report.EndDate); d = d.AddDate(0, 0, 1) </span><span class="cov8" title="1">{
                dateStr := d.Format("2006-01-02")
                dayMap[dateStr] = &amp;DailyStat{
                        Date: dateStr,
                }
        }</span>

        // PRがある日のデータを埋める
        <span class="cov8" title="1">for _, day := range report.Days </span><span class="cov8" title="1">{
                dateStr := day.Date.Format("2006-01-02")
                stat, ok := dayMap[dateStr]
                if !ok </span><span class="cov0" title="0">{
                        stat = &amp;DailyStat{Date: dateStr}
                        dayMap[dateStr] = stat
                }</span>

                <span class="cov8" title="1">var additions, deletions int
                for _, p := range day.Opened </span><span class="cov8" title="1">{
                        additions += p.Additions
                        deletions += p.Deletions
                }</span>
                <span class="cov8" title="1">for _, p := range day.Draft </span><span class="cov0" title="0">{
                        additions += p.Additions
                        deletions += p.Deletions
                }</span>
                <span class="cov8" title="1">for _, p := range day.Merged </span><span class="cov8" title="1">{
                        additions += p.Additions
                        deletions += p.Deletions
                }</span>

                <span class="cov8" title="1">stat.OpenedCount = len(day.Opened)
                stat.DraftCount = len(day.Draft)
                stat.MergedCount = len(day.Merged)
                stat.ReviewedCount = len(day.Reviewed)
                stat.Additions = additions
                stat.Deletions = deletions
                stat.TotalPRs = len(day.Opened) + len(day.Draft) + len(day.Merged) + len(day.Reviewed)</span>
        }

        // スライスに変換
        <span class="cov8" title="1">stats := make([]DailyStat, 0, len(dayMap))
        for _, stat := range dayMap </span><span class="cov8" title="1">{
                stats = append(stats, *stat)
        }</span>

        // グラフ用に日付昇順（左=過去、右=最新）にソート
        <span class="cov8" title="1">sort.Slice(stats, func(i, j int) bool </span><span class="cov8" title="1">{
                return stats[i].Date &lt; stats[j].Date
        }</span>)

        <span class="cov8" title="1">return stats</span>
}

func calcWeeklyStats(report *pr.Report) []WeeklyStat <span class="cov8" title="1">{
        type weekData struct {
                stat    *WeeklyStat
                weekKey string
        }
        weekMap := make(map[string]*weekData)

        for _, day := range report.Days </span><span class="cov8" title="1">{
                year, week := day.Date.ISOWeek()
                weekKey := fmt.Sprintf("%d-W%02d", year, week)

                if _, ok := weekMap[weekKey]; !ok </span><span class="cov8" title="1">{
                        // Calculate week start date (Monday) for label
                        weekStart := day.Date.AddDate(0, 0, -int(day.Date.Weekday())+1)
                        if day.Date.Weekday() == 0 </span><span class="cov0" title="0">{ // Sunday
                                weekStart = day.Date.AddDate(0, 0, -6)
                        }</span>
                        <span class="cov8" title="1">weekEnd := weekStart.AddDate(0, 0, 6) // Sunday
                        weekLabel := fmt.Sprintf("%d/%d 〜 %d/%d", weekStart.Month(), weekStart.Day(), weekEnd.Month(), weekEnd.Day())
                        weekMap[weekKey] = &amp;weekData{
                                stat: &amp;WeeklyStat{
                                        Week:      weekLabel,
                                        StartDate: weekStart.Format("2006-01-02"),
                                        EndDate:   weekEnd.Format("2006-01-02"),
                                },
                                weekKey: weekKey,
                        }</span>
                }

                <span class="cov8" title="1">weekMap[weekKey].stat.OpenedCount += len(day.Opened)
                weekMap[weekKey].stat.DraftCount += len(day.Draft)
                weekMap[weekKey].stat.MergedCount += len(day.Merged)
                weekMap[weekKey].stat.ReviewedCount += len(day.Reviewed)</span>
        }

        <span class="cov8" title="1">stats := make([]WeeklyStat, 0, len(weekMap))
        keys := make([]string, 0, len(weekMap))
        for k := range weekMap </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        for _, k := range keys </span><span class="cov8" title="1">{
                stats = append(stats, *weekMap[k].stat)
        }</span>

        <span class="cov8" title="1">return stats</span>
}

func calcMonthlyStats(report *pr.Report) []MonthlyStat <span class="cov8" title="1">{
        monthMap := make(map[string]*MonthlyStat)

        for _, day := range report.Days </span><span class="cov8" title="1">{
                monthKey := day.Date.Format("2006-01")
                monthLabel := day.Date.Format("Jan 2006")

                if _, ok := monthMap[monthKey]; !ok </span><span class="cov8" title="1">{
                        // Calculate month start and end dates
                        monthStart := time.Date(day.Date.Year(), day.Date.Month(), 1, 0, 0, 0, 0, day.Date.Location())
                        monthEnd := monthStart.AddDate(0, 1, -1) // Last day of month
                        monthMap[monthKey] = &amp;MonthlyStat{
                                Month:     monthLabel,
                                StartDate: monthStart.Format("2006-01-02"),
                                EndDate:   monthEnd.Format("2006-01-02"),
                        }
                }</span>

                <span class="cov8" title="1">monthMap[monthKey].OpenedCount += len(day.Opened)
                monthMap[monthKey].DraftCount += len(day.Draft)
                monthMap[monthKey].MergedCount += len(day.Merged)
                monthMap[monthKey].ReviewedCount += len(day.Reviewed)</span>
        }

        <span class="cov8" title="1">stats := make([]MonthlyStat, 0, len(monthMap))
        keys := make([]string, 0, len(monthMap))
        for k := range monthMap </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        for _, k := range keys </span><span class="cov8" title="1">{
                stats = append(stats, *monthMap[k])
        }</span>

        <span class="cov8" title="1">return stats</span>
}

func calcRepoStats(report *pr.Report) []RepoStat <span class="cov8" title="1">{
        repoCount := make(map[string]int)
        for _, day := range report.Days </span><span class="cov8" title="1">{
                for _, p := range day.Opened </span><span class="cov8" title="1">{
                        repoCount[p.Repository]++
                }</span>
                <span class="cov8" title="1">for _, p := range day.Draft </span><span class="cov0" title="0">{
                        repoCount[p.Repository]++
                }</span>
                <span class="cov8" title="1">for _, p := range day.Merged </span><span class="cov8" title="1">{
                        repoCount[p.Repository]++
                }</span>
                <span class="cov8" title="1">for _, p := range day.Reviewed </span><span class="cov8" title="1">{
                        repoCount[p.Repository]++
                }</span>
        }

        <span class="cov8" title="1">stats := make([]RepoStat, 0, len(repoCount))
        for repo, count := range repoCount </span><span class="cov8" title="1">{
                stats = append(stats, RepoStat{
                        Repository: repo,
                        Count:      count,
                })
        }</span>

        // 件数の多い順にソート
        <span class="cov8" title="1">sort.Slice(stats, func(i, j int) bool </span><span class="cov8" title="1">{
                return stats[i].Count &gt; stats[j].Count
        }</span>)

        <span class="cov8" title="1">return stats</span>
}

func calcSummaryDiff(current Summary, previousReport *pr.Report) SummaryDiff <span class="cov8" title="1">{
        if previousReport == nil </span><span class="cov8" title="1">{
                return SummaryDiff{HasPrevious: false}
        }</span>

        <span class="cov8" title="1">prev := calcSummary(previousReport)
        return SummaryDiff{
                OpenedDiff:   current.OpenedCount - prev.OpenedCount,
                DraftDiff:    current.DraftCount - prev.DraftCount,
                MergedDiff:   current.MergedCount - prev.MergedCount,
                ReviewedDiff: current.ReviewedCount - prev.ReviewedCount,
                HasPrevious:  true,
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "bytes"
        "fmt"
        "net/http"
        "os"
        "os/exec"
        "runtime"
        "time"

        "github.com/taikicoco/shiraberu/internal/pr"
        "github.com/taikicoco/shiraberu/internal/render"
)

const DefaultPort = "7777"

// BrowserOpener はブラウザを開く機能を抽象化するインターフェース
type BrowserOpener interface {
        Open(url string) error
}

// DefaultBrowserOpener はOSのデフォルトブラウザを開く実装
type DefaultBrowserOpener struct{}

// Open はURLをデフォルトブラウザで開く
func (o *DefaultBrowserOpener) Open(url string) error <span class="cov0" title="0">{
        var cmd *exec.Cmd
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                cmd = exec.Command("open", url)</span>
        case "linux":<span class="cov0" title="0">
                cmd = exec.Command("xdg-open", url)</span>
        case "windows":<span class="cov0" title="0">
                cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", url)</span>
        }
        <span class="cov0" title="0">if cmd != nil </span><span class="cov0" title="0">{
                return cmd.Start()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Server はHTTPサーバーの設定を保持する
type Server struct {
        browserOpener BrowserOpener
}

// ServerOption はServerの設定オプション
type ServerOption func(*Server)

// WithBrowserOpener はBrowserOpenerを設定するオプション
func WithBrowserOpener(opener BrowserOpener) ServerOption <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov8" title="1">{
                s.browserOpener = opener
        }</span>
}

// NewServer は新しいServerインスタンスを作成する
func NewServer(opts ...ServerOption) *Server <span class="cov8" title="1">{
        s := &amp;Server{
                browserOpener: &amp;DefaultBrowserOpener{},
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(s)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Serve はデフォルト設定でサーバーを起動する（後方互換性のため）
func Serve(report *pr.Report, previousReport *pr.Report) error <span class="cov0" title="0">{
        return NewServer().ServeReport(report, previousReport)
}</span>

// ServeReport はレポートをHTTPサーバーで提供する
func (s *Server) ServeReport(report *pr.Report, previousReport *pr.Report) error <span class="cov0" title="0">{
        port := os.Getenv("SHIRABERU_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = DefaultPort
        }</span>
        <span class="cov0" title="0">return s.ServeWithAddr(report, previousReport, ":"+port)</span>
}

// ServeWithAddr は指定アドレスでサーバーを起動する（後方互換性のため）
func ServeWithAddr(report *pr.Report, previousReport *pr.Report, addr string) error <span class="cov0" title="0">{
        return NewServer().ServeWithAddr(report, previousReport, addr)
}</span>

// ServeWithAddr は指定アドレスでサーバーを起動する
func (s *Server) ServeWithAddr(report *pr.Report, previousReport *pr.Report, addr string) error <span class="cov8" title="1">{
        var buf bytes.Buffer
        if err := render.RenderHTML(&amp;buf, report, previousReport); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">content := buf.Bytes()

        mux := http.NewServeMux()
        mux.HandleFunc("/", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                _, _ = w.Write(content)
        }</span>)

        <span class="cov8" title="1">server := &amp;http.Server{
                Addr:    addr,
                Handler: mux,
        }

        go func() </span><span class="cov8" title="1">{
                time.Sleep(500 * time.Millisecond)
                _ = s.browserOpener.Open("http://localhost" + addr)
        }</span>()

        <span class="cov8" title="1">fmt.Println("✓ Opening in browser: http://localhost" + addr)
        fmt.Println("Press Ctrl+C to stop the server")

        return server.ListenAndServe()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package spinner

import (
        "fmt"
        "io"
        "os"
        "sync"
        "time"
)

var frames = []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}

type Spinner struct {
        message string
        writer  io.Writer
        stop    chan struct{}
        done    chan struct{}
        mu      sync.Mutex
        running bool
}

func New(message string) *Spinner <span class="cov8" title="1">{
        return &amp;Spinner{
                message: message,
                writer:  os.Stdout,
                stop:    make(chan struct{}),
                done:    make(chan struct{}),
        }
}</span>

func (s *Spinner) Start() <span class="cov8" title="1">{
        s.mu.Lock()
        if s.running </span><span class="cov8" title="1">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">s.running = true
        s.mu.Unlock()

        go func() </span><span class="cov8" title="1">{
                ticker := time.NewTicker(80 * time.Millisecond)
                defer ticker.Stop()

                i := 0
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-s.stop:<span class="cov8" title="1">
                                // Clear the spinner line
                                fmt.Fprintf(s.writer, "\r\033[K")
                                close(s.done)
                                return</span>
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                fmt.Fprintf(s.writer, "\r%s %s", frames[i%len(frames)], s.message)
                                i++</span>
                        }
                }
        }()
}

func (s *Spinner) Stop() <span class="cov8" title="1">{
        s.mu.Lock()
        if !s.running </span><span class="cov8" title="1">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">s.running = false
        s.mu.Unlock()

        close(s.stop)
        &lt;-s.done</span>
}

func (s *Spinner) Success(message string) <span class="cov8" title="1">{
        s.Stop()
        fmt.Fprintf(s.writer, "✓ %s\n", message)
}</span>

func (s *Spinner) Fail(message string) <span class="cov8" title="1">{
        s.Stop()
        fmt.Fprintf(s.writer, "✗ %s\n", message)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "flag"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/taikicoco/shiraberu/internal/config"
        "github.com/taikicoco/shiraberu/internal/demo"
        "github.com/taikicoco/shiraberu/internal/github"
        "github.com/taikicoco/shiraberu/internal/period"
        "github.com/taikicoco/shiraberu/internal/pr"
        "github.com/taikicoco/shiraberu/internal/prompt"
        "github.com/taikicoco/shiraberu/internal/render"
        "github.com/taikicoco/shiraberu/internal/server"
        "github.com/taikicoco/shiraberu/internal/spinner"
)

var demoMode = flag.Bool("demo", false, "Run with demo data (no GitHub API calls)")

func main() <span class="cov0" title="0">{
        flag.Parse()

        if err := run(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func run() error <span class="cov0" title="0">{
        // Demo mode
        if *demoMode </span><span class="cov0" title="0">{
                return runDemo()
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">opts, err := prompt.Run(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client, err := github.NewClient()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create GitHub client: %w", err)
        }</span>

        <span class="cov0" title="0">fetcher := pr.NewFetcher(client)

        // Fetch current period with spinner
        spin := spinner.New("Fetching PRs...")
        spin.Start()
        report, err := fetcher.Fetch(opts.Org, opts.StartDate, opts.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                spin.Fail("Failed to fetch PRs")
                return fmt.Errorf("failed to fetch PRs: %w", err)
        }</span>
        <span class="cov0" title="0">spin.Success("Fetched PRs")

        // Fetch previous period for comparison
        var previousReport *pr.Report
        spin = spinner.New("Fetching previous period...")
        spin.Start()
        prevStartDate, prevEndDate := period.CalcPrevious(opts.StartDate, opts.EndDate, opts.PeriodType)
        previousReport, err = fetcher.Fetch(opts.Org, prevStartDate, prevEndDate)
        if err != nil </span><span class="cov0" title="0">{
                spin.Fail("Previous period unavailable")
                previousReport = nil
        }</span> else<span class="cov0" title="0"> {
                spin.Success("Fetched previous period")
        }</span>

        <span class="cov0" title="0">switch opts.Format </span>{
        case "browser":<span class="cov0" title="0">
                return server.Serve(report, previousReport)</span>
        case "html":<span class="cov0" title="0">
                return writeOutput(opts.OutputPath, func(w io.Writer) error </span><span class="cov0" title="0">{
                        return render.RenderHTML(w, report, previousReport)
                }</span>)
        default:<span class="cov0" title="0"> // markdown
                return writeOutput(opts.OutputPath, func(w io.Writer) error </span><span class="cov0" title="0">{
                        return render.RenderMarkdown(w, report)
                }</span>)
        }
}

// writeOutput はレンダリング結果をファイルまたは標準出力に書き込む
func writeOutput(path string, renderer func(io.Writer) error) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return renderer(os.Stdout)
        }</span>

        <span class="cov0" title="0">f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        if err := renderer(f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("✓ Saved to %s\n", path)
        return nil</span>
}

func runDemo() error <span class="cov0" title="0">{
        fmt.Println("Demo mode: Generating sample data...")

        // Generate demo data for last 30 days
        endDate := time.Now()
        startDate := endDate.AddDate(0, 0, -30)

        report, previousReport := demo.GenerateReport(startDate, endDate)

        fmt.Printf("Generated %d days of demo data\n", len(report.Days))

        return server.Serve(report, previousReport)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
